#+TITLE:Expresso basics 
#+AUTHOR: Maik SchÃ¼nemann
#+email: maikschuenemann@gmail.com
#+STARTUP:showall
-----

The code of this section is in the expresso-tutorial.expresso-basics namespace
#+begin_src clojure :exports both :results output :tangle yes
  (ns expresso-tutorial.expresso-basics
    (:use [numeric.expresso.core]))
#+end_src

* Expressions
  Central datastructure of expresso is an Expression.
  Clojure, being a lisp, already has a proven and simple way to encode
  expressions, namely s-expressions.
  Expresso follows the lisp approach and encodes expressions as s-expressions.
  That means, that every user-facing expression Type will implement ISeq, so 
  you can use *all the clojure sequence functions* to manipulate expressions.
  Currently, clojure's in-build lists with metadata added is the default 
  expression Type.

** Constructing Expressions
   while all functions in numeric.expresso.core accept plain s-expressions as 
   arguments, the ex-macros are very convenient for creating expressions suitable
   for further manipulation by expresso.

  #+begin_src clojure :exports both :results output :tangle yes
    ;;you can think of ex as a better form of quoting to construct s-expressions
    (def expr (ex (+ (* a x) (* b x) (- x))))
    
    (first expr) ;=> +
    (rest expr)  ;=> ((* a x) (* b x) (- x))
    
    ;;unquoting is also supported
    (ex (+ (* a x) ~(+ 3 (* 4 5)))) ;=> (+ (* a x) 23)
    
    ;;the ex' macro requires you to explicitly quote the symbols
    (let [x 3]
      (ex' (+ x 'x)))  ;=> (+ 3 x)
    
    ;;it also takes an optional symbol vector indicating symbols to quote
    (let [x 3]
      (ex' [x] (+ x ~x))) ;=> (+ x 3)
    
  #+end_src
   For the simple case, there is no need to explicitly construct symbols before
   creating the expression.
   
** Annotating Symbols
   Expresso also lets you specify properties about the symbols in the expression.
   By default, expresso assumes the simple case: It assumes the symbol represents
   a number with no additional properties.
   There a two ways to annotate the symbols in the expression.
*** directly in the ex-macros
    The expresso constructing functions/macros respect the :matrix, :shape and
    :properties keys in the metadata, so you can directly specify them imline
    #+begin_src clojure :exports both :results output :tangle yes
    ;;x represents a matrix here
    (def expr (ex (+ ^:matrix x 1)))
    ;;thus, its shape is not determined
    (shape (nth expr 1)) ;=> <lvar:shape_....>
    ;;you can also directly specify a shape
    ;;the matrix annotation is not neccesary here
    (def expr (ex (+ ^{:shape [2 2]} x 1)))
    (shape (nth expr 1)) ;=> [2 2]

    ;;to specify extra properties, use the properties metadata to specify a 
    ;;set of properties.
    (def expr (ex (+ ^{:shape [2 2] :properties #{:mzero}} x 1)))
    (properties (nth expr 1)) ;=> #{:mzero}

    ;;currently, :mzero and :midentity are used for zero and identity-matrices.
    ;;In future, expresso will respect more properties.
    #+end_src

*** explicitly constructing symbols
    The second way to annotate symbols is especially useful when one symbol is 
    used in more than one place or in more expressions. For this cases, expresso
    provides the functions expresso-symbol, matrix-symbol and the functions
    zero-matrix and identity-matrix, each of which is examplified below

    
